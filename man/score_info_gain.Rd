% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/score-info_gain.R
\docType{data}
\name{score_info_gain}
\alias{score_info_gain}
\alias{score_gain_ratio}
\alias{score_sym_uncert}
\title{Scoring via entropy-based filters}
\format{
An object of class \code{filtro::class_score_info_gain} (inherits from \code{filtro::class_score}, \code{S7_object}) of length 1.

An object of class \code{filtro::class_score_info_gain} (inherits from \code{filtro::class_score}, \code{S7_object}) of length 1.

An object of class \code{filtro::class_score_info_gain} (inherits from \code{filtro::class_score}, \code{S7_object}) of length 1.
}
\usage{
score_info_gain

score_gain_ratio

score_sym_uncert
}
\arguments{
\item{object}{A score class object based on \code{score_info_gain}.}

\item{formula}{A standard R formula with a single outcome on the right-hand
side and one or more predictors (or \code{.}) on the left-hand side. The data are
processed via \code{\link[stats:model.frame]{stats::model.frame()}}.}

\item{data}{A data frame containing the relevant columns defined by the
formula.}

\item{...}{Further arguments passed to or from other methods.}
}
\description{
These objects are used when either:
\itemize{
\item The predictors are numeric and the outcome is a factor/category, or
\item The predictors are factors and the outcome is numeric.
}

In either case, an entropy-based filter (via \code{\link[FSelectorRcpp:information_gain]{FSelectorRcpp::information_gain()}})
is applied with the proper variable roles. Depending on the chosen method, information
gain, gain ratio, or symmetrical uncertainty is computed. Larger values are associated
with more important predictors.

\code{score_info_gain}, \code{score_gain_ratio} and \code{score_sym_uncert} are
objects that define the technique.
To apply the filter on data, you would use the \code{\link[=fit]{fit()}} method:

\preformatted{
fit(score_info_gain, formula, data)
}

See the Examples section below.
}
\details{
The function will determine which columns are predictors and outcomes in the
filter; no user intervention is required.

Missing values are removed for each predictor/outcome combination being
scored.
When a predictor's importance score is 0, the gain ratio method may omit its
name from the results. In cases like these, a score of 0 is assigned to the
missing predictors.
}
\examples{
rlang::is_installed("modeldata")

library(dplyr)

# Entropy-based filter for classification tasks

cells_subset <- modeldata::cells |>
  dplyr::select(
    class,
    angle_ch_1,
    area_ch_1,
    avg_inten_ch_1,
    avg_inten_ch_2,
    avg_inten_ch_3
  )

# Information gain
cells_info_gain_res <- score_info_gain |>
  fit(class ~ ., data = cells_subset)
cells_info_gain_res@results

# Gain ratio
cells_gain_ratio_res <- score_gain_ratio |>
  fit(class ~ ., data = cells_subset)
cells_gain_ratio_res@results

# Symmetrical uncertainty
cells_sym_uncert_res <- score_sym_uncert |>
  fit(class ~ ., data = cells_subset)
cells_sym_uncert_res@results

# ----------------------------------------------------------------------------

# Entropy-based filter for regression tasks

ames_subset <- modeldata::ames |>
  dplyr::select(
    Sale_Price,
    MS_SubClass,
    MS_Zoning,
    Lot_Frontage,
    Lot_Area,
    Street
  )
ames_subset <- ames_subset |>
  dplyr::mutate(Sale_Price = log10(Sale_Price))

regression_task <- score_info_gain
regression_task@mode <- "regression"

ames_info_gain_regression_task_res <-
  regression_task |>
  fit(Sale_Price ~ ., data = ames_subset)
ames_info_gain_regression_task_res@results
}
\keyword{datasets}
