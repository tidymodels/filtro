---
title: "Scoring via random forests"
vignette: >
  %\VignetteIndexEntry{Scoring via random forests}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

> ⚠️ **work-in-progress**

```{r, start, include = FALSE}
library(filtro)
library(dplyr)
library(modeldata)
```

```{r}
#| label: setup
library(filtro)
library(dplyr)
library(modeldata)
```

## A score class object

Predictor importance can be assessed using three different random forest models via the following objects:

```{r eval = FALSE}
score_imp_rf
score_imp_rf_conditional
score_imp_rf_oblique
```

These models are implemented in the following packages:

```{r}
score_imp_rf@engine
score_imp_rf_conditional@engine
score_imp_rf_oblique@engine
```

Regarding score types:

- The {ranger} random forest computes the importance scores.

- The {partykit} conditional random forest computes the conditional importance scores.

- The {aorsf} oblique computes the permutation importance scores.

## A random forest scoring example

The {modeldata} package contains a data set used to predict which cells in a high content screen were well segmented. It has 57 predictor columns and a factor variable `class` (the outcome). 

Since `case` is only used to indicate Train/Test, not for data analysis, it will be set to `NULL`. Furthermore, for efficiency, we will use a small sample of 50 from the original 2019 observations.

```{r}
cells_subset <- modeldata::cells |> 
  # use a small example for efficiency
  dplyr::slice(1:50)
cells_subset$case <- NULL

# cells_subset |> str() # uncomment to see the structure of the data
```

First, we create a score class object to specify a {ranger} random forest, and then use the `fit()` method with the standard formula to compute the importance scores.

The data frame of results can be accessed via `object@results`. 

```{r}
# specify random forest and fit score
cells_imp_rf_res <- score_imp_rf |>
  fit(
    class ~ .,
    data = cells_subset, 
    seed = 42 
  )
cells_imp_rf_res@results
```

Like {parsnip}, the argument names are harmonized. For example, to set the number of trees: `num.trees` in {ranger}, `ntree` in {partykit}, and `n_tree` in {aorsf} are all standardized to a single name, `trees`, so users only need to remember a single name. The same applies to the number of variables to split at each node, `mtry`, and the minimum node size for splitting, `min_n`.

```{r}
# Set hyperparameters
cells_imp_rf_res <- score_imp_rf |>
  fit(
    class ~ .,
    data = cells_subset,     
    trees = 100,
    mtry = 2,
    min_n = 1, 
    seed = 42 
  )
cells_imp_rf_res@results
```

However, there is one argument name specific to {ranger}. For reproducibility, instead of using the standard `set.seed()` method, users must use the `seed` argument.

```{r eval = FALSE}
cells_imp_rf_res <- score_imp_rf |>
  fit(
    class ~ .,
    data = cells_subset,     
    trees = 100,
    mtry = 2,
    min_n = 1, 
    seed = 42 # set seed for reproducibility
  )
```

If users use the argument names from {ranger}, that’s fine. We’ve handled the necessary adjustments for them. The following code chunk can be used to obtain the same fitted score: 

```{r eval = FALSE}
cells_imp_rf_res <- score_imp_rf |>
  fit(
    class ~ .,
    data = cells_subset,     
    num.trees = 100,
    mtry = 2,
    min.node.size = 1, 
    seed = 42 
  )
```

## A conditional random forest scoring example

For the {partykit} conditional random forest, we again create a score class object to specify the model, then use the `fit()` method to compute the importance scores.

The data frame of results can be accessed via `object@results`. 

```{r}
# set seed for reproducibility
set.seed(42)

# specify conditional random forest and fit score
cells_imp_rf_conditional_res <- score_imp_rf_conditional |>
  fit(class ~ ., data = cells_subset, trees = 3)
cells_imp_rf_conditional_res@results
```


## An oblique random forest scoring example

For the {aorsf} oblique random forest, we again create a score class object to specify the model, then use the `fit()` method to compute the importance scores.

The data frame of results can be accessed via `object@results`. 

```{r}
# set seed for reproducibility
set.seed(42)

# specify oblique random forest and fit score
cells_imp_rf_oblique_res <- score_imp_rf_oblique |>
  fit(class ~ ., data = cells_subset, trees = 100, mtry = 2)
cells_imp_rf_oblique_res@results
```
